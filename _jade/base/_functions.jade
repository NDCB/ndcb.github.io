-
    /**
        Retrieves the URL of the current document.
    */
    function getCurrentUrl() {
        let url = public._data.globals.url;
        return url + current.path.join('/');
    }

    /**
        Retrieves the relative path of the current document.
    */
    function getCurrentRelativePath() {
        return "/" + current.path.join('/');
    }

    /**
        Returns the base name of the current document file.
    */
    function getFileBaseName() {
        return current.path[current.path.length - 1];
    }

    /**
        Scans through the articles of the root's data for
        a slug matching the name of the current document and
        returns the article metadata if there is a match.
    */
    function fetchArticleMetadata() {
        let currentRoot = getCurrentRoot();
        let articles = currentRoot._data.articles;
        if (articles) {
            let fileName = getFileBaseName();
            if (articles[fileName]){
                return articles[fileName];
            }
        }
    }

    /**
        Scans through the pages of the root's data for
        a slug matching the name of the current document and
        returns the page metadata if there is a match.
    */
    function fetchPageMetadata() {
        let currentRoot = getCurrentRoot();
        let pages = currentRoot._data.pages;
        if (pages) {
            let fileName = getFileBaseName();
            if (pages[fileName]){
                return pages[fileName];
            }
        }
    }

    /**
        Scans through the articles and pages of the root's data
        for a slug matching the name of the current document and
        returns its metadata if there is a match.
    */
    function fetchDocumentMetadata() {
        let articleMeta = fetchArticleMetadata();
        let pageMeta = fetchPageMetadata();
        if (articleMeta) {
            return articleMeta;
        } else if (pageMeta) {
            return pageMeta;
        } else {
            console.warn(
                "Warning: Could not locate document " 
                + "metadata at " + getCurrentRelativePath()
            );
        }
    }

    /**
        Determines whether or not the current document is an article.
    */
    function currentIsArticle() {
        let articleMeta = fetchArticleMetadata();
        if (articleMeta) {
            return true;
        } else {
            return false;
        }
    }

    /**
        Retrieves the root node of the current document in the 
        flexible metadata structure.
    */
    function getCurrentRoot() {
        let path = current.path;
        let root = public;
        for (let i = 0; i < path.length - 1; i++){
            root = root[path[i]];
        }
        return root;
    }

    /**
        Retrieves the root node of the locale of the current
        document.
    */
    function getCurrentLocaleRoot() {
        let path = current.path;
        if (path.length > 1) {
            return public[path[0]];
        }
    }

    /**
        Fetches the URL of the thumbnail of the current document.
    */
    function fetchCurrentThumbnailUrl() {
        let url;
        let path = current.path;
        let root = public;
        for (let i = 0; i < path.length - 1; i++){
            root = root[path[i]];
            if (root._data) {
                if (root._data.categories) {
                    let categories = root._data.categories;
                    if (categories[path[i + 1]]) {
                        let category = categories[path[i + 1]];
                        if (category.thumbnail) {
                            url = public._data.globals.url 
                            + "res/thumbnails/" 
                            + category.thumbnail;
                        }
                    }
                }
            }
        }
        return url;
    }

    /**
        Fetches the color class of the main component of this document
        based on the attribute of the category in the hierarchy. 
    */
    function fetchCurrentMainColorClass(defaultColorClass) {
        let colorClass = defaultColorClass;
        let path = current.path;
        let root = public;
        for (let i = 0; i < path.length - 1; i++){
            root = root[path[i]];
            if (root._data) {
                if (root._data.categories) {
                    let categories = root._data.categories;
                    if (categories[path[i + 1]]) {
                        let category = categories[path[i + 1]];
                        if (category.colorClass) {
                            colorClass = category.colorClass; 
                        }
                    }
                }
            }
        }
        return colorClass;
    }

    /**
        Retrieves the variables of the locale of the current document.
    */
    function fetchCurrentLocaleVariables() {
        let path = current.path;
        let locales = public._data.locales;
        if (path.length > 1) {
            let locale = locales[path[0]];
            if (locale) {
                return locale.variables;
            }
        }
    }

    /**
        Retrieves the HTML lang parameter of the current document.
    */
    function getCurrentHtmlLocale() {
        let path = current.path;
        if (path.length > 1){
            let locale = public._data.locales[path[0]];
            if (locale) {
                return locale.languageCode + '-' + locale.countryCode;
            }
        }
    }

    /**
        Retrieves the og:locale of the current document.
    */
    function getCurrentOgLocale() {
        let path = current.path;
        if (path.length > 1){
            let locale = public._data.locales[path[0]];
            if (locale) {
                return locale.languageCode + '_' + locale.countryCode;
            }
        }
    }

    /**
        Fetches all the articles of the site.
    */
    function fetchAllArticles() {
        let articles = [];
        let locales = public._data.locales;
        for (let slug in locales) {
            articles = articles.concat(
                fetchArticles(
                    public[slug], 
                    '/' + slug + '/',
                    slug
                )
            );
        }
        return articles;
    }

    /**
        Recursively fetches all articles accross the categories of
        a node.
    */
    function fetchArticles(root, path, locale) {
        let articles = [];
        if (root._data.articles) {
            let localArticles = root._data.articles;
            for (let slug in localArticles) {
                let article = localArticles[slug];
                articles.push({
                    info: article,
                    path: path + slug,
                    locale: locale
                });
            }
        }
        if (root._data.categories) {
            let categories = root._data.categories;
            for (slug in categories) {
                articles = articles.concat(
                    fetchArticles(
                        root[slug], 
                        path + slug + '/',
                        locale
                    )
                );
            }
        }
        return articles;
    }

    function fetchAboutPageUrl(localeCode) {
        let locale = public[localeCode];
        if (locale) {
            for (page in locale._data.pages) {
                if (locale._data.pages[page].aboutPage) {
                    return '/' + localeCode + '/' + page;
                }
            }
        }
    }

    function linkPerson(localeCode, personId) {
        return fetchAboutPageUrl(localeCode) + '#' + personId;
    }

    function getPersonFullName(localeCode, personId) {
        let locale = public[localeCode];
        let data = locale._data;
        let persons = data.persons;
        if (persons) {
            for (person in persons) {
                if (person === personId) {
                    let info = persons[person];
                    return info.fullName;
                }
            }
        }
    }

    /**
        Parses date in the YYYY-MM-DD format to a localized
        format.
    */
    function stringDate(dateString, localeCode) {
        if (dateString) {
            let date = dateString.split('-');
            for (var i = 0; i < date.length; i++) {
                date[i] = parseInt(date[i]);
            }
            let locales = public._data.locales;
            let locale = locales[localeCode];
            let variables = locale.variables;
            let months = variables.time.months;
            let languageCode = locale.languageCode;
            let result;
            switch (languageCode) {
                case "fr":
                    let day;
                    if (date[2] === 1) {
                        day = "1er";
                    } else {
                        day = date[2];
                    }
                    result = day 
                    + ' ' 
                    + months[date[1] - 1].toLowerCase()
                    + ' '
                    + date[0];
                    break;
                case "en":
                    result = months[date.getMonth()]
                    + ' '
                    + date.getDate()
                    + ", "
                    + date.getFullYear();
                    break;
            }
            return result;
        } else {
            return '';
        }
    }

    /**
        Slugifies a text for URLs.
    */
    function slugify(text) {
        if (text){
            text = text.toLowerCase();
            //- Replace apostrophes
            text = text.replace(/\u0027/g, ' '); 
            //- Remove commas
            text = text.replace(/\u002C/g, ''); 
            //- Replace accented as
            text = text.replace(/[\u00E0-\u00E5]/gi, 'a') 
            //- Replace accented es
            text = text.replace(/[\u00E8-\u00EB]/gi, 'e') 
            //- Replace accented is
            text = text.replace(/[\u00EC-\u00EF]/gi, 'i') 
            //- Replace accented os
            text = text.replace(/[\u00F2-\u00F6]/gi, 'o')
            //- Replace accented us
            text = text.replace(/[\u00F9-\u00FC]/gi, 'u') 
            //- Remove excess spaces
            text = text.trim().replace(/  +/g, ' ')
            //- Replace spaces with dashes
            text = text.replace(/ /g, '-') 
            return text;
        } else {
            console.error(
                "Error: Undefined text to slugify " 
                + getCurrentRelativePath()
            );
        }
    }